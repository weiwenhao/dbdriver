import io
import net.tcp
import fmt
import mem
import crypto.sha256
import crypto.rsa
import time
import libc
import base64
import db.result

// MySQL protocol constants
const CLIENT_PROTOCOL_41 = 0x00000200
const CLIENT_SECURE_CONNECTION = 0x00008000
const CLIENT_PLUGIN_AUTH = 0x00080000
const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000

// MySQL commands
const COM_QUERY = 0x03
const COM_QUIT = 0x01
const COM_STMT_PREPARE = 0x16
const COM_STMT_EXECUTE = 0x17
const COM_STMT_CLOSE = 0x19

// Packet type identifiers
const PACKET_OK = 0x00
const PACKET_ERROR = 0xff
const PACKET_EOF = 0xfe
const PACKET_AUTH = 0x01

// Authentication plugins
const AUTH_NATIVE_PASSWORD = "mysql_native_password"
const AUTH_CACHING_SHA2 = "caching_sha2_password"

// Authentication status
const AUTH_SUCCESS = 0x03
const AUTH_FAIL = 0x04

// caching_sha2_password authentication status
const AUTH_MORE_DATA = 0x01
const AUTH_FAST_PATH = 0x03
const AUTH_FULL_AUTH = 0x04

// caching_sha2_password request types
const REQUEST_PUBLIC_KEY = 0x02
const FAST_AUTH_SUCCESS = 0x03
const PERFORM_FULL_AUTH = 0x04

// MySQL field types - complete definition
const MYSQL_TYPE_DECIMAL = 0x00
const MYSQL_TYPE_TINY = 0x01
const MYSQL_TYPE_SHORT = 0x02
const MYSQL_TYPE_LONG = 0x03
const MYSQL_TYPE_FLOAT = 0x04
const MYSQL_TYPE_DOUBLE = 0x05
const MYSQL_TYPE_NULL = 0x06
const MYSQL_TYPE_TIMESTAMP = 0x07
const MYSQL_TYPE_LONGLONG = 0x08
const MYSQL_TYPE_INT24 = 0x09
const MYSQL_TYPE_DATE = 0x0a
const MYSQL_TYPE_TIME = 0x0b
const MYSQL_TYPE_DATETIME = 0x0c
const MYSQL_TYPE_YEAR = 0x0d
const MYSQL_TYPE_NEWDATE = 0x0e
const MYSQL_TYPE_VARCHAR = 0x0f
const MYSQL_TYPE_BIT = 0x10
const MYSQL_TYPE_NEWDECIMAL = 0xf6
const MYSQL_TYPE_ENUM = 0xf7
const MYSQL_TYPE_SET = 0xf8
const MYSQL_TYPE_TINY_BLOB = 0xf9
const MYSQL_TYPE_MEDIUM_BLOB = 0xfa
const MYSQL_TYPE_LONG_BLOB = 0xfb
const MYSQL_TYPE_BLOB = 0xfc
const MYSQL_TYPE_VAR_STRING = 0xfd
const MYSQL_TYPE_STRING = 0xfe
const MYSQL_TYPE_GEOMETRY = 0xff

// Handshake packet structure
type handshake_packet_t = struct {
    string server_version
    [u8] auth_data
    string auth_plugin
}

// Prepared statement type
type stmt_t = struct {
    ptr<conn_t> conn
    u32 statement_id
    u16 param_count
    u16 column_count
    string query_string
}

// MySQL connection type
type conn_t = struct {
    ptr<tcp.conn_t> conn
    u8 seq_id
    bool closed
    [u8] auth_data  // Store auth_data for full authentication
}

// Create connection with specified configuration
fn connect(string host, string username, string password, string database):ptr<conn_t>! {
    var conn = tcp.connect_timeout(host, 10000)

    var client = new conn_t(conn, seq_id = 0, closed = false, auth_data = [])

    // Execute authentication process
    client.authenticate(username, password)

    // Set charset to utf8mb4 to support full UTF-8 character set including emoji
    client.set_charset("utf8mb4")

    if database != "" {
        client.execute(fmt.sprintf("CREATE DATABASE IF NOT EXISTS %s", database))
        client.execute(fmt.sprintf("USE %s", database))
    }

    return client
}

// Authentication process
fn conn_t.authenticate(string username, string password):void! {
    // Read handshake packet
    var handshake = self.read_handshake()

    // Store auth_data for potential full authentication
    self.auth_data = handshake.auth_data

    // Send authentication response
    self.send_auth_response(username, password, handshake)

    // Handle authentication result
    self.handle_auth_result(password)
}

// Read handshake packet
fn conn_t.read_handshake():handshake_packet_t! {
    var packet = self.read_packet()

    if packet.len() == 0 || packet[0] == PACKET_ERROR {
        throw errorf("Server handshake failed")
    }

    return self.parse_handshake_packet(packet)
}

// Parse handshake packet
fn conn_t.parse_handshake_packet([u8] packet):handshake_packet_t! {
    if packet.len() < 20 {
        throw errorf("Handshake packet length insufficient")
    }

    var pos = 1 // Skip protocol version

    // Parse server version
    var (server_version, new_pos) = self.read_null_terminated_string(packet, pos)
    pos = new_pos

    // Skip connection ID (4 bytes)
    pos += 4

    // Read first part of auth data (8 bytes)
    if pos + 8 > packet.len() {
        throw errorf("Handshake packet format error")
    }
    var auth_data1 = packet.slice(pos, pos + 8)
    pos += 9 // Including reserved byte

    // Skip capability flags and other fields
    pos += 2 // Lower capability flags
    if pos >= packet.len() {
        return handshake_packet_t{
            server_version: server_version,
            auth_data: auth_data1,
            auth_plugin: AUTH_NATIVE_PASSWORD,
        }
    }

    pos += 1  // Character set
    pos += 2  // Status flags
    pos += 2  // Upper capability flags
    var auth_data_len = packet[pos]
    pos += 1
    pos += 10 // Reserved bytes

    // Read second part of auth data
    var auth_data2 = vec_new<u8>(0, 0)
    if auth_data_len > 8 && pos < packet.len() {
        var remaining_len = auth_data_len as int - 8
        if pos + remaining_len <= packet.len() {
            auth_data2 = packet.slice(pos, pos + remaining_len - 1)
            pos += remaining_len
        }
    }

    // Read authentication plugin name
    var (auth_plugin, _) = self.read_null_terminated_string(packet, pos)
    if auth_plugin == "" {
        auth_plugin = AUTH_NATIVE_PASSWORD
    }

    return handshake_packet_t{
        server_version: server_version,
        auth_data: auth_data1.concat(auth_data2),
        auth_plugin: auth_plugin,
    }
}

// Send authentication response
fn conn_t.send_auth_response(string username, string password, handshake_packet_t handshake):void! {
    u32 capabilities = CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | CLIENT_PLUGIN_AUTH | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA

    var auth_response = self.generate_auth_response(password, handshake.auth_data, handshake.auth_plugin)

    var packet = self.build_auth_packet(capabilities, username, auth_response, handshake.auth_plugin)
    self.write_packet(packet)
}

// Generate authentication response
fn conn_t.generate_auth_response(string password, [u8] auth_data, string auth_plugin):[u8]! {
    if password == "" {
        return []
    }

    match auth_plugin {
        'caching_sha2_password' -> {
            return self.caching_sha2_auth(password, auth_data)
        }
        'mysql_native_password' -> {
            return self.native_password_auth(password, auth_data)
        }
        _ -> {
            throw errorf('unknown auth plugin: ', auth_plugin)
        }
    }
}

// Build authentication packet
fn conn_t.build_auth_packet(u32 capabilities, string username, [u8] auth_response, string auth_plugin):[u8]! {
    var packet = vec_cap<u8>(256)

    // Client capability flags (4 bytes)
    var cap_bytes = mem.write_u32_le(capabilities)
    packet.append(cap_bytes)

    // Maximum packet size (4 bytes)
    packet.append([0x00, 0x00, 0x00, 0x01])

    // Character set (1 byte)
    packet.push(0xe0) // utf8mb4_general_ci

    // Reserved bytes (23 bytes)
    packet.append(vec_new<u8>(0, 23))

    // Username
    packet.append(username as [u8])
    packet.push(0x00)

    // Authentication response
    packet.push(auth_response.len() as u8)
    packet.append(auth_response)

    // Authentication plugin name
    packet.append(auth_plugin as [u8])
    packet.push(0x00)

    return packet
}

// Handle authentication result
fn conn_t.handle_auth_result(string password):void! {
    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty authentication response")
    }

    match packet[0] {
        PACKET_OK -> {
            return
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        PACKET_AUTH -> {
            self.handle_caching_sha2_auth(packet, password)
        }
        PACKET_EOF -> {
            throw errorf("Server requested authentication method switch, not supported in this example")
        }
        _ -> {
            throw errorf("Unknown authentication response: 0x%02x", packet[0])
        }
    }
}

// Request RSA public key from server
fn conn_t.request_public_key():[u8]! {
    // Send public key request
    [u8] request_packet = [REQUEST_PUBLIC_KEY]
    self.write_packet(request_packet)

    // Read public key response
    var response = self.read_packet()
    if response.len() == 0 {
        throw errorf("Empty public key response")
    }

    if response[0] == PACKET_ERROR {
        var error_msg = self.parse_error_packet(response)
        throw errorf("Failed to get public key: %s", error_msg)
    }

    // Check if this is an AUTH_MORE_DATA packet containing public key
    if response[0] != AUTH_MORE_DATA {
        throw errorf("Expected AUTH_MORE_DATA packet for public key, got: 0x%02x", response[0])
    }

    // The public key is in the response packet starting from byte 1
    if response.len() <= 1 {
        throw errorf("Invalid public key response format")
    }

    return response[1.. response.len()]
}

// RSA encrypt password for caching_sha2_password authentication
fn conn_t.rsa_encrypt_password(string password, [u8] seed, [u8] public_key_pem):[u8]! {
    var plain = vec_new<u8>(0, password.len() + 1)
    plain.copy(password as [u8])

    for i, v in plain {
        var j  = i % seed.len()
        plain[i] ^= seed[j]
    }
    
    // Parse RSA public key from PEM format
    var pk = rsa.public_key_from_pem(public_key_pem)
    var encrypted = pk.encrypt_oaep(rsa.SHA1, plain, null)
    return encrypted
}

// Handle caching_sha2_password authentication
fn conn_t.handle_caching_sha2_auth([u8] packet, string password):void! {
    if packet.len() <= 1 {
        throw errorf("caching_sha2_password authentication packet format error")
    }

    match packet[1] {
        FAST_AUTH_SUCCESS -> {
            // Fast authentication successful, read final OK packet
            var final_packet = self.read_packet()
            if final_packet.len() > 0 && final_packet[0] == PACKET_OK {
                return
            }
            throw errorf("Expected to receive final OK packet")
        }
        PERFORM_FULL_AUTH -> {
            // Fast authentication failed, need to perform full authentication
            self.perform_full_authentication(password, packet)
        }
        _ -> {
            throw errorf("Unknown caching_sha2_password authentication status: 0x%02x", packet[1])
        }
    }
}

// Perform full authentication for caching_sha2_password
fn conn_t.perform_full_authentication(string password, [u8] initial_packet):void! {
    // Extract auth_data from the initial handshake (stored in connection context)
    var auth_data = self.auth_data
    
    if auth_data.len() == 0 {
        throw errorf("No auth_data available for full authentication")
    }
    
    // Check if we're in a secure connection (TLS or Unix socket)
    // For this implementation, we assume non-secure connection and use RSA encryption
    
    // Request server's RSA public key
    var public_key_pem = self.request_public_key()
    
    if public_key_pem.len() == 0 {
        throw errorf("Failed to obtain server public key")
    }
    
    // Encrypt password with RSA OAEP
    var encrypted_password = self.rsa_encrypt_password(password, auth_data, public_key_pem)
    
    // Send encrypted password
    self.write_packet(encrypted_password)
    
    // Read authentication result - should be an OK packet
    var response = self.read_packet()
    if response.len() == 0 {
        throw errorf("Empty full authentication response")
    }
    
    if response[0] == PACKET_OK {
        // Full authentication successful
        return
    } else if response[0] == PACKET_ERROR {
        var error_msg = self.parse_error_packet(response)
        throw errorf("Full authentication failed: %s", error_msg)
    } else {
        throw errorf("Unexpected full authentication response: 0x%02x", response[0])
    }
}

// mysql_native_password authentication
fn conn_t.native_password_auth(string password, [u8] auth_data):[u8] {
    if password == "" {
        return []
    }

    var hash1 = sha256.new().update(password as [u8]).finish()
    var hash2 = sha256.new().update(hash1).finish()

    var combined = auth_data.concat(hash2)
    var hash3 = sha256.new().update(combined).finish()

    var result = vec_new<u8>(0, hash1.len())
    for int i = 0; i < hash1.len(); i += 1 {
        result[i] = hash1[i] ^ hash3[i]
    }

    return result
}

// caching_sha2_password authentication
fn conn_t.caching_sha2_auth(string password, [u8] scramble):[u8] {
    if password.len() == 0 {
        return []
    }

    // XOR(SHA256(password), SHA256(SHA256(SHA256(password)), scramble))
    var message1 = sha256.new().update(password as [u8]).finish()
    var message1_hash = sha256.new().update(message1).finish()


    var message2 = sha256.new().update(message1_hash).update(scramble).finish()

    for i,v in message1 {
        message1[i] ^= message2[i]
    }

    return message1
}

// Execute non-query statements (INSERT, UPDATE, DELETE, etc.)
fn conn_t.execute(string query):result.execute_t! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet[1..query_packet.len()].copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty query response")
    }

    match packet[0] {
        PACKET_OK -> {
            return self.parse_execute_result(packet)
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            throw errorf("Execute method can only be used for non-query statements")
        }
    }
}

// Execute query statements (SELECT, etc.)
fn conn_t.query(string query):result.query_t! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet[1..query_packet.len()].copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty query response")
    }

    match packet[0] {
        PACKET_OK -> {
            // Possibly a query with no results
            return result.query_t{columns: [], rows: []}
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            return self.parse_query_result(packet)
        }
    }
}

// Prepare statement
fn conn_t.prepare(string query):ptr<stmt_t>! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var prepare_packet = vec_new<u8>(0, 1 + query.len())
    prepare_packet[0] = COM_STMT_PREPARE
    prepare_packet[1..prepare_packet.len()].copy(query as [u8])

    self.write_packet(prepare_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty prepare response")
    }

    if packet[0] == PACKET_ERROR {
        var error_msg = self.parse_error_packet(packet)
        throw errorf(error_msg)
    }

    return self.parse_prepare_response(packet, query)
}

// Set charset for connection
fn conn_t.set_charset(string charset):void! {
    var query = fmt.sprintf("SET NAMES %s", charset)
    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet[1..query_packet.len()].copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty charset setting response")
    }

    match packet[0] {
        PACKET_OK -> {
            return
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf("Failed to set charset: %s", error_msg)
        }
        _ -> {
            throw errorf("Unknown charset setting response: 0x%02x", packet[0])
        }
    }
}

// Close connection
fn conn_t.close() {
    if self.closed {
        return
    }

    self.write_packet([COM_QUIT]) catch e {}

    self.conn.close()
    self.closed = true
}

// Parse execute result
fn conn_t.parse_execute_result([u8] packet):result.execute_t {
    var pos = 1 // Skip OK identifier

    var (affected_rows, new_pos) = self.read_length_encoded_int(packet, pos)
    pos = new_pos
    var (last_insert_id, new_pos2) = self.read_length_encoded_int(packet, pos)
    pos = new_pos2

    var status_flags = 0 as u16
    var warnings = 0 as u16

    if pos + 2 <= packet.len() {
        status_flags = mem.read_u16_le(packet[pos..pos + 2]) catch e {0 as u16}
        pos += 2
    }
    if pos + 2 <= packet.len() {
        warnings = mem.read_u16_le(packet[pos..pos + 2]) catch e {0 as u16}
        pos += 2
    }

    var info = ""
    if pos < packet.len() {
        info = packet[pos..packet.len()] as string
    }

    return result.execute_t{
        affected_rows: affected_rows,
        last_insert_id: last_insert_id,
    }
}

// Parse query result
fn conn_t.parse_query_result([u8] first_packet):result.query_t! {
    var column_count = first_packet[0] as int

    // Read column definitions
    var columns = vec_new<string>("", column_count)
    for int i = 0; i < column_count; i += 1 {
        var col_packet = self.read_packet()
        columns[i] = self.parse_column_name(col_packet)
    }

    // Read EOF packet
    var eof_packet = self.read_packet()

    var rows = vec_new<[string?]>([], 0)

    // If not EOF packet, this is the first row of data
    if !self.is_eof_packet(eof_packet) {
        var row = self.parse_row(eof_packet, column_count)
        rows.push(row)
    }

    // Read all row data
    for true {
        var row_packet = self.read_packet()

        if self.is_eof_packet(row_packet) {
            break
        }

        var row = self.parse_row(row_packet, column_count)
        rows.push(row)
    }

    return result.query_t{
        columns: columns,
        rows: rows,
    }
}

// Parse column name
fn conn_t.parse_column_name([u8] packet):string {
    // Simplified column name parsing, skip most fields and find column name directly
    var pos = 0

    // Skip catalog
    var (_1, new_pos) = self.read_length_encoded_string(packet, pos)
    pos = new_pos
    // Skip schema
    var (_2, new_pos2) = self.read_length_encoded_string(packet, pos)
    pos = new_pos2
    // Skip table
    var (_3, new_pos3) = self.read_length_encoded_string(packet, pos)
    pos = new_pos3
    // Skip org_table
    var (_4, new_pos4) = self.read_length_encoded_string(packet, pos)
    pos = new_pos4
    // Read name (column name)
    var (name, _5) = self.read_length_encoded_string(packet, pos)

    return name
}

// Parse row data
fn conn_t.parse_row([u8] packet, int column_count):[string?] {
    var row = vec_new<string?>(null, column_count)
    var pos = 0

    for int i = 0; i < column_count && pos < packet.len(); i += 1 {
        if packet[pos] == 0xfb {
            row[i] = null
            pos += 1
        } else {
            // Read length-encoded string
            var (length, new_pos) = self.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                row[i] = packet.slice(pos, pos + length as int) as string
                pos += length as int
            }
        }
    }

    return row
}

// Read MySQL packet
fn conn_t.read_packet():[u8]! {
    var header = vec_new<u8>(0, 4)
    var len = self.conn.read(header)
    if len != 4 {
        throw errorf("Failed to read packet header")
    }

    var length = header[0] as int | (header[1] as int << 8) | (header[2] as int << 16)
    self.seq_id = header[3] + 1

    var payload = vec_new<u8>(0, length)
    len = self.conn.read(payload)
    if len != length {
        throw errorf("Failed to read packet body")
    }

    return payload
}

// Write MySQL packet
fn conn_t.write_packet([u8] payload):void! {
    var length = payload.len()
    [u8] header = [length as u8, (length >> 8) as u8, (length >> 16) as u8, self.seq_id]

    self.seq_id += 1

    self.conn.write(header)
    self.conn.write(payload)
}

// Check if it's an EOF packet
fn conn_t.is_eof_packet([u8] packet):bool {
    return packet.len() > 0 && packet[0] == PACKET_EOF && packet.len() < 9
}

// Read null-terminated string
fn conn_t.read_null_terminated_string([u8] data, int pos):(string, int) {
    var start = pos
    for pos < data.len() && data[pos] != 0 {
        pos += 1
    }
    return (data.slice(start, pos) as string, pos + 1)
}

// Read length-encoded string
fn conn_t.read_length_encoded_string([u8] data, int pos):(string, int) {
    var (length, new_pos) = self.read_length_encoded_int(data, pos)
    pos = new_pos
    if pos + length as int <= data.len() {
        return (data.slice(pos, pos + length as int) as string, pos + length as int)
    }
    return ("", pos)
}

// Read length-encoded integer
fn conn_t.read_length_encoded_int([u8] data, int pos):(int, int) {
    if pos >= data.len() {
        return (0, pos)
    }

    var first = data[pos]
    match first {
        0xfb -> {
            return (0, pos)
        }
        0xfc -> {
            if pos + 2 >= data.len() {
                return (0, pos)
            }
            var value = mem.read_u16_le(data.slice(pos + 1, pos + 3)) catch e {0}
            return (value as int, pos + 3)
        }
        0xfd -> {
            if pos + 3 >= data.len() {
                return (0, pos)
            }
            var value = data[pos + 1] as int | (data[pos + 2] as int << 8) | (data[pos + 3] as int << 16)
            return (value, pos + 4)
        }
        0xfe -> {
            if pos + 8 >= data.len() {
                return (0, pos)
            }
            var value = mem.read_i64_le(data.slice(pos + 1, pos + 9)) catch e {0}
            return (value, pos + 9)
        }
        _ -> {
            return (first as int, pos + 1)
        }
    }
}

// Parse prepare response
fn conn_t.parse_prepare_response([u8] packet, string query):ptr<stmt_t>! {
    if packet.len() < 12 {
        throw errorf("Prepare response packet length insufficient")
    }

    var pos = 1 // Skip status identifier
    var statement_id = mem.read_u32_le(packet.slice(pos, pos + 4)) catch e {0}
    pos += 4
    var column_count = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0}
    pos += 2
    var param_count = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0}

    var stmt = new stmt_t(
        conn = self,
        statement_id = statement_id,
        param_count = param_count,
        column_count = column_count,
        query_string = query,
    )

    // If there are parameters, need to read parameter definition packets
    if param_count > 0 {
        for u16 i = 0; i < param_count; i += 1 {
            self.read_packet()
        }
        // Read parameter EOF packet
        self.read_packet()
    }

    // If there are columns, need to read column definition packets
    if column_count > 0 {
        for u16 i = 0; i < column_count; i += 1 {
            self.read_packet()
        }
        // Read column EOF packet
        self.read_packet()
    }

    return stmt
}

// Execute prepared statement
fn stmt_t.execute(...[any] args):result.execute_t! {
    if self.conn.closed {
        throw errorf("Connection is closed")
    }

    self.conn.seq_id = 0

    var execute_packet = self.build_execute_packet(args)
    self.conn.write_packet(execute_packet)

    var packet = self.conn.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty execute response")
    }

    match packet[0] {
        PACKET_OK -> {
            return self.conn.parse_execute_result(packet)
        }
        PACKET_ERROR -> {
            var error_msg = self.conn.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            throw errorf("Execute method can only be used for non-query statements")
        }
    }
}

// Query with prepared statement
fn stmt_t.query(...[any] args):result.query_t! {
    if self.conn.closed {
        throw errorf("Connection is closed")
    }

    self.conn.seq_id = 0

    var execute_packet = self.build_execute_packet(args)
    self.conn.write_packet(execute_packet)

    var packet = self.conn.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty execute response")
    }

    match packet[0] {
        PACKET_OK -> {
            return result.query_t{columns: [], rows: []}
        }
        PACKET_ERROR -> {
            var error_msg = self.conn.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            return self.parse_binary_query_result(packet)
        }
    }
}

// Close prepared statement
fn stmt_t.close():void! {
    if self.conn.closed {
        return
    }

    self.conn.seq_id = 0

    var close_packet = vec_new<u8>(0, 5)
    close_packet[0] = COM_STMT_CLOSE
    var stmt_id_bytes = mem.write_u32_le(self.statement_id)
    close_packet.slice(1, 5).copy(stmt_id_bytes)

    self.conn.write_packet(close_packet)
}

// Build execute packet
fn stmt_t.build_execute_packet([any] args):[u8]! {
    var packet = vec_cap<u8>(1024)

    // Command type
    packet.push(COM_STMT_EXECUTE)

    // Statement ID
    var stmt_id_bytes = mem.write_u32_le(self.statement_id)
    packet.append(stmt_id_bytes)

    // Flags
    packet.push(0x00)

    // Iteration count
    packet.append([0x01, 0x00, 0x00, 0x00])

    if args.len() > 0 {
        // NULL bitmap
        var null_bitmap_len = (args.len() + 7) / 8
        var null_bitmap = vec_new<u8>(0, null_bitmap_len)
        
        // Fill NULL bitmap - mark NULL values
        for i,arg in args {
            if args[i] is null {
                var byte_index = i / 8
                var bit_index = i % 8
                null_bitmap[byte_index] = null_bitmap[byte_index] | (1 << bit_index as u8)
            }
        }
        
        packet.append(null_bitmap)

        // New parameter binding flag
        packet.push(0x01)

        // Parameter types
        for arg in args {
            match arg {
                is null -> {
                    packet.append([MYSQL_TYPE_NULL, 0x00]) // MYSQL_TYPE_NULL
                }
                is string -> {
                    packet.append([MYSQL_TYPE_STRING, 0x00]) // MYSQL_TYPE_STRING
                }
                is bool -> {
                    packet.append([MYSQL_TYPE_TINY, 0x00]) // MYSQL_TYPE_TINY (for boolean)
                }
                is i8|is u8 -> {
                    packet.append([MYSQL_TYPE_TINY, 0x00]) // MYSQL_TYPE_TINY
                }
                is i16|is u16 -> {
                    packet.append([MYSQL_TYPE_SHORT, 0x00]) // MYSQL_TYPE_SHORT
                }
                is i32|is u32 -> {
                    packet.append([MYSQL_TYPE_LONG, 0x00]) // MYSQL_TYPE_LONG
                }
                is i64|is u64 -> {
                    packet.append([MYSQL_TYPE_LONGLONG, 0x00]) // MYSQL_TYPE_LONGLONG
                }
                is f32 -> {
                    packet.append([MYSQL_TYPE_FLOAT, 0x00]) // MYSQL_TYPE_FLOAT
                }
                is f64|is float -> {
                    packet.append([MYSQL_TYPE_DOUBLE, 0x00]) // MYSQL_TYPE_DOUBLE
                }
                _ -> {
                    throw errorf('unsupported argument type')
                }
            }
        }

        // Parameter values - skip NULL values as per MySQL protocol
        for arg in args {
            match arg {
                is null -> {
                    // NULL values are handled by NULL bitmap, no data written
                }
                is string s -> {
                    var str_bytes = s as [u8]
                    var length_bytes = self.encode_length_encoded_int(str_bytes.len() as u64)
                    packet.append(length_bytes)
                    packet.append(str_bytes)
                }
                is bool v -> {
                    if v {
                        packet.push(1)
                    } else {
                        packet.push(0) 
                    }
                }
                is i16 v -> {
                    var bytes = mem.write_i16_le(v)
                    packet.append(bytes)
                }
                is u16 v -> {
                    var bytes = mem.write_u16_le(v)
                    packet.append(bytes)
                }
                is i32 v -> {
                    var bytes = mem.write_i32_le(v)
                    packet.append(bytes)
                }
                is u32 v -> {
                    var bytes = mem.write_u32_le(v)
                    packet.append(bytes)
                }
                is i64 v -> {
                    var bytes = mem.write_i64_le(v)
                    packet.append(bytes)
                }
                is u64 v -> {
                    var bytes = mem.write_u64_le(v)
                    packet.append(bytes)
                }
                is f32 v -> {
                    packet.append(mem.write_f32_le(v as f32))
                }
                is f64 v -> {
                    packet.append(mem.write_f64_le(v as f64))
                }
                _ -> {
                    throw errorf('unsupported argument type')
                }
            }
        }
    }

    return packet
}

// Encode length-encoded integer
fn stmt_t.encode_length_encoded_int(u64 value):[u8] {
    if value < 251 {
        return [value as u8]
    } else if value < 65536 {
        var result = vec_new<u8>(0, 3)
        result[0] = 0xfc
        var val_bytes = mem.write_u16_le(value as u16) catch e {[]}
        result.slice(1, 3).copy(val_bytes)
        return result
    } else if value < 16777216 {
        var result = vec_new<u8>(0, 4)
        result[0] = 0xfd
        result[1] = value as u8
        result[2] = (value >> 8) as u8
        result[3] = (value >> 16) as u8
        return result
    } else {
        var result = vec_new<u8>(0, 9)
        result[0] = 0xfe
        var val_bytes = mem.write_u64_le(value) catch e {[]}
        result.slice(1, 9).copy(val_bytes)
        return result
    }
}

// Parse binary query result (for prepared statements)
fn stmt_t.parse_binary_query_result([u8] first_packet):result.query_t! {
    var column_count = first_packet[0] as int

    // Read column definitions
    var columns = vec_new<string>("", column_count)
    var column_types = vec_new<u8>(0, column_count)
    
    for int i = 0; i < column_count; i += 1 {
        var col_packet = self.conn.read_packet()
        columns[i] = self.conn.parse_column_name(col_packet)
        column_types[i] = self.parse_column_type(col_packet)
    }

    // Read EOF packet
    var eof_packet = self.conn.read_packet()

    var rows = vec_new<[string?]>([], 0)

    // If not EOF packet, this is the first row of data
    if !self.conn.is_eof_packet(eof_packet) {
        var row = self.parse_binary_row_with_types(eof_packet, column_count, column_types)
        rows.push(row)
    }

    // Read all row data
    for true {
        var row_packet = self.conn.read_packet()

        if self.conn.is_eof_packet(row_packet) {
            break
        }

        var row = self.parse_binary_row_with_types(row_packet, column_count, column_types)
        rows.push(row)
    }

    return result.query_t{
        columns: columns,
        rows: rows,
    }
}

// Parse column type
fn stmt_t.parse_column_type([u8] packet):u8 {
    var pos = 0
    
    // Skip catalog, schema, table, org_table, name, org_name
    var (_1, new_pos) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos
    var (_2, new_pos2) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos2
    var (_3, new_pos3) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos3
    var (_4, new_pos4) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos4
    var (_5, new_pos5) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos5
    var (_6, new_pos6) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos6
    
    // Skip fixed length identifier (0x0c)
    if pos < packet.len() && packet[pos] == 0x0c {
        pos += 1
    }
    
    // Skip charset (2 bytes)
    pos += 2
    // Skip column length (4 bytes)
    pos += 4
    
    // Field type (1 byte)
    if pos < packet.len() {
        return packet[pos]
    }
    
    // Default to string type
    return 0xfe
}

// Parse binary row with types
fn stmt_t.parse_binary_row_with_types([u8] packet, int column_count, [u8] column_types):[string?] {
    if packet.len() == 0 {
        return vec_new<string?>("", column_count)
    }

    // Skip packet header identifier (0x00)
    var pos = 1

    // NULL bitmap length calculation
    var null_bitmap_len = (column_count + 7 + 2) / 8
    if pos + null_bitmap_len > packet.len() {
        return vec_new<string?>("", column_count)
    }

    var null_bitmap = packet[pos..pos + null_bitmap_len]
    pos += null_bitmap_len

    var row = vec_new<string?>("", column_count)

    for int i = 0; i < column_count; i += 1 {
        // Check NULL bitmap
        var byte_pos = (i + 2) / 8
        var bit_pos = (i + 2) % 8
        if byte_pos < null_bitmap.len() && (null_bitmap[byte_pos] & (1 << bit_pos as u8)) != 0 {
            row[i] = null
            continue
        }

        // If position exceeds packet length, set to empty string
        if pos >= packet.len() {
            row[i] = ""
            continue
        }

        // Parse data by field type
        var field_value = ""
        var new_pos = pos
        
        if i < column_types.len() {
            var (value, next_pos) = self.parse_binary_field_by_type(packet, pos, column_types[i])
            field_value = value
            new_pos = next_pos
        } else {
            // Default string handling
            var (length, tmp_pos) = self.conn.read_length_encoded_int(packet, pos)
            new_pos = tmp_pos
            if new_pos + length as int <= packet.len() {
                field_value = packet.slice(new_pos, new_pos + length as int) as string
                new_pos += length as int
            }
        }
        
        row[i] = field_value
        pos = new_pos
    }

    return row
}

// Parse binary field by type
fn stmt_t.parse_binary_field_by_type([u8] packet, int pos, u8 field_type):(string, int) {
    match field_type {
        MYSQL_TYPE_DECIMAL|MYSQL_TYPE_NEWDECIMAL -> {
            // For decimal types, treat as string for now
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_TINY -> {
            if pos + 1 <= packet.len() {
                return (fmt.sprintf("%d", packet[pos] as i8), pos + 1)
            }
        }
        MYSQL_TYPE_SHORT -> {
            if pos + 2 <= packet.len() {
                var val = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0}
                return (fmt.sprintf("%d", val), pos + 2)
            }
        }
        MYSQL_TYPE_LONG|MYSQL_TYPE_INT24 -> {
            if pos + 4 <= packet.len() {
                var val = mem.read_u32_le(packet.slice(pos, pos + 4)) catch e {0}
                return (fmt.sprintf("%d", val), pos + 4)
            }
        }
        MYSQL_TYPE_LONGLONG -> {
            if pos + 8 <= packet.len() {
                var val = mem.read_u64_le(packet.slice(pos, pos + 8)) catch e {0}
                return (fmt.sprintf("%d", val), pos + 8)
            }
        }
        MYSQL_TYPE_FLOAT -> {
            if pos + 4 <= packet.len() {
                var val = mem.read_u32_le(packet.slice(pos, pos + 4)) catch e {0}
                return (fmt.sprintf("%g", val as f32), pos + 4)
            }
        }
        MYSQL_TYPE_DOUBLE -> {
            if pos + 8 <= packet.len() {
                var val = mem.read_u64_le(packet.slice(pos, pos + 8)) catch e {0}
                return (fmt.sprintf("%g", val as f64), pos + 8)
            }
        }
        MYSQL_TYPE_NULL -> {
            return ("NULL", pos)
        }
        MYSQL_TYPE_TIMESTAMP|MYSQL_TYPE_DATE|MYSQL_TYPE_TIME|MYSQL_TYPE_DATETIME|MYSQL_TYPE_YEAR|MYSQL_TYPE_NEWDATE -> {
            // Date/time types, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_VARCHAR|MYSQL_TYPE_VAR_STRING|MYSQL_TYPE_STRING -> {
            // String types
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_TINY_BLOB|MYSQL_TYPE_MEDIUM_BLOB|MYSQL_TYPE_LONG_BLOB|MYSQL_TYPE_BLOB -> {
            // BLOB types, treat as string for now
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_BIT -> {
            // BIT type, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_ENUM|MYSQL_TYPE_SET -> {
            // ENUM and SET types, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_GEOMETRY -> {
            // GEOMETRY type, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        _ -> {
            // Unknown types, use length-encoded string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
    }
    
    return ("", pos)
}

// Parse error packet
fn conn_t.parse_error_packet([u8] packet):string {
    if packet.len() < 3 {
        return "Error packet format incorrect"
    }

    var error_code = mem.read_u16_le(packet.slice(1, 3)) catch e {0}
    var error_message = ""

    if packet.len() > 3 {
        if packet[3] == '#'[0] && packet.len() > 9 {
            error_message = packet.slice(9, packet.len()) as string
        } else {
            error_message = packet.slice(3, packet.len()) as string
        }
    }

    return fmt.sprintf("MySQL error %d: %s", error_code, error_message)
}

// Print query results in table format

fn main():void! {
    fmt.printf("=== MySQL API Refactoring Test ===\n")
    fmt.printf("\n")

    // Create connection
    var c = connect("127.0.0.1:3306", "root", "root", "test_db")

    fmt.printf("Connection successful!\n")

    // Create user table
    fmt.printf("\n=== Create User Table ===\n")
    var r = c.execute("CREATE TABLE IF NOT EXISTS users (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), email VARCHAR(100), age INT)")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Insert data
    fmt.printf("\n=== Insert User Data ===\n")
    r = c.execute("INSERT INTO users (name, email, age) VALUES ('Zhang San', 'zhangsan@example.com', 25)")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = c.execute("INSERT INTO users (name, email, age) VALUES ('Li Si', 'lisi@example.com', 30)")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = c.execute("INSERT INTO users (name, email, age) VALUES ('Wang Wu', NULL, 28)")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    // Query data
    fmt.printf("\n=== Query User Data ===\n")
    var r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Update data
    fmt.printf("\n=== Update User Data ===\n")
    r = c.execute("UPDATE users SET email = 'zhangsan_new@example.com' WHERE id = 1")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Query data again
    fmt.printf("\n=== Query Updated Data ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // scan result set
    fmt.printf("\n=== scan Result Set ===\n")
    type user_t = struct{
        int id
        string name
        string? email
        int age
    }
    var list = result.scan<user_t>(r2) 
    for item in list {
        fmt.printf("ID: %d, Name: %s, Email: %v, Age: %d\n", item.id, item.name, item.email, item.age)
    }

    // Delete data
    fmt.printf("\n=== Delete User Data ===\n")
    r = c.execute("DELETE FROM users WHERE id = 2")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Final query
    fmt.printf("\n=== Final Query Results ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Query system information
    fmt.printf("\n=== Query System Information ===\n")
    r2 = c.query("SELECT NOW() as now_time, VERSION() as version, USER() as `current_user`")
    r2.dump()

    // Test prepared statements
    fmt.printf("\n=== Test Prepared Statements ===\n")

    // Prepare insert statement
    var insert_stmt = c.prepare("INSERT INTO users (name, email, age) VALUES (?, ?, ?)")

    // Use prepared statement to insert data
    r = insert_stmt.execute("Zhao Liu", "zhaoliu@example.com", 35)
    fmt.printf("Prepared insert affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = insert_stmt.execute("Sun Qi", null, 22)
    fmt.printf("Prepared insert affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    // Prepare query statement
    var select_stmt = c.prepare("SELECT * FROM users WHERE id > ?")

    // Use prepared statement to query data
    fmt.printf("\n=== Prepared Query Results (id > 1) ===\n")
    var r3 = select_stmt.query(1)
    r3.dump()

    // Prepare update statement
    var update_stmt = c.prepare("UPDATE users SET email = ? WHERE name = ?")

    // Use prepared statement to update data
    r = update_stmt.execute("zhaoliu_updated@example.com", "Zhao Liu")
    fmt.printf("Prepared update affected rows: %d\n", r.affected_rows)

    // View results after update
    fmt.printf("\n=== Results After Prepared Update ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Close prepared statements
    insert_stmt.close()
    select_stmt.close()
    update_stmt.close()

    // Cleanup
    fmt.printf("\n=== Cleanup Test Data ===\n")
    r = c.execute("DROP TABLE IF EXISTS users")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    c.close()

    fmt.printf("\n=== API Test Completed ===\n")
}
