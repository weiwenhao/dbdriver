import io
import net.tcp
import fmt
import mem
import crypto.sha256
import time
import libc
import base64

// MySQL protocol constants
const CLIENT_PROTOCOL_41 = 0x00000200
const CLIENT_SECURE_CONNECTION = 0x00008000
const CLIENT_PLUGIN_AUTH = 0x00080000
const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000

// MySQL commands
const COM_QUERY = 0x03
const COM_QUIT = 0x01
const COM_STMT_PREPARE = 0x16
const COM_STMT_EXECUTE = 0x17
const COM_STMT_CLOSE = 0x19

// Packet type identifiers
const PACKET_OK = 0x00
const PACKET_ERROR = 0xff
const PACKET_EOF = 0xfe
const PACKET_AUTH = 0x01

// Authentication plugins
const AUTH_NATIVE_PASSWORD = "mysql_native_password"
const AUTH_CACHING_SHA2 = "caching_sha2_password"

// Authentication status
const AUTH_SUCCESS = 0x03
const AUTH_FAIL = 0x04

// MySQL field types - complete definition
const MYSQL_TYPE_DECIMAL = 0x00
const MYSQL_TYPE_TINY = 0x01
const MYSQL_TYPE_SHORT = 0x02
const MYSQL_TYPE_LONG = 0x03
const MYSQL_TYPE_FLOAT = 0x04
const MYSQL_TYPE_DOUBLE = 0x05
const MYSQL_TYPE_NULL = 0x06
const MYSQL_TYPE_TIMESTAMP = 0x07
const MYSQL_TYPE_LONGLONG = 0x08
const MYSQL_TYPE_INT24 = 0x09
const MYSQL_TYPE_DATE = 0x0a
const MYSQL_TYPE_TIME = 0x0b
const MYSQL_TYPE_DATETIME = 0x0c
const MYSQL_TYPE_YEAR = 0x0d
const MYSQL_TYPE_NEWDATE = 0x0e
const MYSQL_TYPE_VARCHAR = 0x0f
const MYSQL_TYPE_BIT = 0x10
const MYSQL_TYPE_NEWDECIMAL = 0xf6
const MYSQL_TYPE_ENUM = 0xf7
const MYSQL_TYPE_SET = 0xf8
const MYSQL_TYPE_TINY_BLOB = 0xf9
const MYSQL_TYPE_MEDIUM_BLOB = 0xfa
const MYSQL_TYPE_LONG_BLOB = 0xfb
const MYSQL_TYPE_BLOB = 0xfc
const MYSQL_TYPE_VAR_STRING = 0xfd
const MYSQL_TYPE_STRING = 0xfe
const MYSQL_TYPE_GEOMETRY = 0xff

// Handshake packet structure
type handshake_packet_t = struct {
    string server_version
    [u8] auth_data
    string auth_plugin
}

// Execute result type
type execute_result_t = struct {
    u64 affected_rows    // Number of affected rows
    u64 last_insert_id   // Last inserted ID
    u16 status_flags     // Status flags
    u16 warnings         // Number of warnings
    string info          // Additional information
}

// Query result type
type query_result_t = struct {
    [string] columns     // Column names
    [[string]] rows      // Data rows
}

// Prepared statement type
type stmt_t = struct {
    ptr<conn_t> conn
    u32 statement_id
    u16 param_count
    u16 column_count
    string query_string
}

// MySQL connection type
type conn_t = struct {
    ptr<tcp.conn_t> conn
    u8 seq_id
    bool closed
}

// Create connection with specified configuration
fn connect(string host, string username, string password):ptr<conn_t>! {
    var conn = tcp.connect_timeout(host, 10000)

    var client = new conn_t(conn, seq_id = 0, closed = false)

    // Execute authentication process
    client.authenticate(username, password)

    // Set charset to utf8mb4 to support full UTF-8 character set including emoji
    client.set_charset("utf8mb4")

    return client
}

// Authentication process
fn conn_t.authenticate(string username, string password):void! {
    // Read handshake packet
    var handshake = self.read_handshake()

    // Send authentication response
    self.send_auth_response(username, password, handshake)

    // Handle authentication result
    self.handle_auth_result(password)
}

// Read handshake packet
fn conn_t.read_handshake():handshake_packet_t! {
    var packet = self.read_packet()

    if packet.len() == 0 || packet[0] == PACKET_ERROR {
        throw errorf("Server handshake failed")
    }

    return self.parse_handshake_packet(packet)
}

// Parse handshake packet
fn conn_t.parse_handshake_packet([u8] packet):handshake_packet_t! {
    if packet.len() < 20 {
        throw errorf("Handshake packet length insufficient")
    }

    var pos = 1 // Skip protocol version

    // Parse server version
    var (server_version, new_pos) = self.read_null_terminated_string(packet, pos)
    pos = new_pos

    // Skip connection ID (4 bytes)
    pos += 4

    // Read first part of auth data (8 bytes)
    if pos + 8 > packet.len() {
        throw errorf("Handshake packet format error")
    }
    var auth_data1 = packet.slice(pos, pos + 8)
    pos += 9 // Including reserved byte

    // Skip capability flags and other fields
    pos += 2 // Lower capability flags
    if pos >= packet.len() {
        return handshake_packet_t{
            server_version = server_version,
            auth_data = auth_data1,
            auth_plugin = AUTH_NATIVE_PASSWORD,
        }
    }

    pos += 1  // Character set
    pos += 2  // Status flags
    pos += 2  // Upper capability flags
    var auth_data_len = packet[pos]
    pos += 1
    pos += 10 // Reserved bytes

    // Read second part of auth data
    var auth_data2 = vec_new<u8>(0, 0)
    if auth_data_len > 8 && pos < packet.len() {
        var remaining_len = auth_data_len as int - 8
        if pos + remaining_len <= packet.len() {
            auth_data2 = packet.slice(pos, pos + remaining_len - 1)
            pos += remaining_len
        }
    }

    // Read authentication plugin name
    var (auth_plugin, _) = self.read_null_terminated_string(packet, pos)
    if auth_plugin == "" {
        auth_plugin = AUTH_NATIVE_PASSWORD
    }

    return handshake_packet_t{
        server_version = server_version,
        auth_data = auth_data1.concat(auth_data2),
        auth_plugin = auth_plugin,
    }
}

// Send authentication response
fn conn_t.send_auth_response(string username, string password, handshake_packet_t handshake):void! {
    u32 capabilities = CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | CLIENT_PLUGIN_AUTH | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA

    var auth_response = self.generate_auth_response(password, handshake.auth_data, handshake.auth_plugin)

    var packet = self.build_auth_packet(capabilities, username, auth_response, handshake.auth_plugin)
    self.write_packet(packet)
}

// Generate authentication response
fn conn_t.generate_auth_response(string password, [u8] auth_data, string auth_plugin):[u8] {
    if password == "" {
        return []
    }

    match auth_plugin {
        AUTH_CACHING_SHA2 -> {
            return self.caching_sha2_auth(password, auth_data)
        }
        _ -> {
            return self.native_password_auth(password, auth_data)
        }
    }
}

// Build authentication packet
fn conn_t.build_auth_packet(u32 capabilities, string username, [u8] auth_response, string auth_plugin):[u8]! {
    var packet = vec_cap<u8>(256)

    // Client capability flags (4 bytes)
    var cap_bytes = mem.write_u32_le(capabilities)
    packet.append(cap_bytes)

    // Maximum packet size (4 bytes)
    packet.append([0x00, 0x00, 0x00, 0x01])

    // Character set (1 byte)
    packet.push(0xe0) // utf8mb4_general_ci

    // Reserved bytes (23 bytes)
    packet.append(vec_new<u8>(0, 23))

    // Username
    packet.append(username as [u8])
    packet.push(0x00)

    // Authentication response
    packet.push(auth_response.len() as u8)
    packet.append(auth_response)

    // Authentication plugin name
    packet.append(auth_plugin as [u8])
    packet.push(0x00)

    return packet
}

// Handle authentication result
fn conn_t.handle_auth_result(string password):void! {
    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty authentication response")
    }

    match packet[0] {
        PACKET_OK -> {
            return
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        PACKET_AUTH -> {
            self.handle_caching_sha2_auth(packet)
        }
        PACKET_EOF -> {
            throw errorf("Server requested authentication method switch, not supported in this example")
        }
        _ -> {
            throw errorf("Unknown authentication response: 0x%02x", packet[0])
        }
    }
}

// Handle caching_sha2_password authentication
fn conn_t.handle_caching_sha2_auth([u8] packet):void! {
    if packet.len() <= 1 {
        throw errorf("caching_sha2_password authentication packet format error")
    }

    match packet[1] {
        AUTH_SUCCESS -> {
            // Fast authentication successful, read final OK packet
            var final_packet = self.read_packet()
            if final_packet.len() > 0 && final_packet[0] == PACKET_OK {
                return
            }
            throw errorf("Expected to receive final OK packet")
        }
        AUTH_FAIL -> {
            throw errorf("Fast authentication failed")
        }
        _ -> {
            throw errorf("Full authentication required, but RSA encryption not supported in this example")
        }
    }
}

// mysql_native_password authentication
fn conn_t.native_password_auth(string password, [u8] auth_data):[u8] {
    if password == "" {
        return []
    }

    var hash1 = sha256.new().update(password as [u8]).finish()
    var hash2 = sha256.new().update(hash1).finish()

    var combined = auth_data.concat(hash2)
    var hash3 = sha256.new().update(combined).finish()

    var result = vec_new<u8>(0, hash1.len())
    for int i = 0; i < hash1.len(); i += 1 {
        result[i] = hash1[i] ^ hash3[i]
    }

    return result
}

// caching_sha2_password authentication
fn conn_t.caching_sha2_auth(string password, [u8] auth_data):[u8] {
    if password == "" {
        return []
    }

    var hash1 = sha256.new().update(password as [u8]).finish()
    var hash2 = sha256.new().update(hash1).finish()

    var combined = hash2.concat(auth_data)

    var hash3 = sha256.new().update(combined).finish()

    var result = vec_new<u8>(0, hash1.len())
    for int i = 0; i < hash1.len(); i += 1 {
        result[i] = hash1[i] ^ hash3[i]
    }

    return result
}

// Execute non-query statements (INSERT, UPDATE, DELETE, etc.)
fn conn_t.execute(string query):execute_result_t! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet.slice(1, query_packet.len()).copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty query response")
    }

    match packet[0] {
        PACKET_OK -> {
            return self.parse_execute_result(packet)
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            throw errorf("Execute method can only be used for non-query statements")
        }
    }
}

// Execute query statements (SELECT, etc.)
fn conn_t.query(string query):query_result_t! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet.slice(1, query_packet.len()).copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty query response")
    }

    match packet[0] {
        PACKET_OK -> {
            // Possibly a query with no results
            return query_result_t{columns = [], rows = []}
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            return self.parse_query_result(packet)
        }
    }
}

// Prepare statement
fn conn_t.prepare(string query):ptr<stmt_t>! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var prepare_packet = vec_new<u8>(0, 1 + query.len())
    prepare_packet[0] = COM_STMT_PREPARE
    prepare_packet.slice(1, prepare_packet.len()).copy(query as [u8])

    self.write_packet(prepare_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty prepare response")
    }

    if packet[0] == PACKET_ERROR {
        var error_msg = self.parse_error_packet(packet)
        throw errorf(error_msg)
    }

    return self.parse_prepare_response(packet, query)
}

// Set charset for connection
fn conn_t.set_charset(string charset):void! {
    var query = fmt.sprintf("SET NAMES %s", charset)
    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet.slice(1, query_packet.len()).copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty charset setting response")
    }

    match packet[0] {
        PACKET_OK -> {
            return
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf("Failed to set charset: %s", error_msg)
        }
        _ -> {
            throw errorf("Unknown charset setting response: 0x%02x", packet[0])
        }
    }
}

// Close connection
fn conn_t.close() {
    if self.closed {
        return
    }

    self.write_packet([COM_QUIT]) catch e {}

    self.conn.close()
    self.closed = true
}

// Parse execute result
fn conn_t.parse_execute_result([u8] packet):execute_result_t {
    var pos = 1 // Skip OK identifier

    var (affected_rows, new_pos) = self.read_length_encoded_int(packet, pos)
    pos = new_pos
    var (last_insert_id, new_pos2) = self.read_length_encoded_int(packet, pos)
    pos = new_pos2

    var status_flags = 0 as u16
    var warnings = 0 as u16

    if pos + 2 <= packet.len() {
        status_flags = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0 as u16}
        pos += 2
    }
    if pos + 2 <= packet.len() {
        warnings = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0 as u16}
        pos += 2
    }

    var info = ""
    if pos < packet.len() {
        info = packet.slice(pos, packet.len()) as string
    }

    return execute_result_t{
        affected_rows = affected_rows,
        last_insert_id = last_insert_id,
        status_flags = status_flags,
        warnings = warnings,
        info = info,
    }
}

// Parse query result
fn conn_t.parse_query_result([u8] first_packet):query_result_t! {
    var column_count = first_packet[0] as int

    // Read column definitions
    var columns = vec_new<string>("", column_count)
    for int i = 0; i < column_count; i += 1 {
        var col_packet = self.read_packet()
        columns[i] = self.parse_column_name(col_packet)
    }

    // Read EOF packet
    var eof_packet = self.read_packet()

    var rows = vec_new<[string]>([], 0)

    // If not EOF packet, this is the first row of data
    if !self.is_eof_packet(eof_packet) {
        var row = self.parse_row(eof_packet, column_count)
        rows.push(row)
    }

    // Read all row data
    for true {
        var row_packet = self.read_packet()

        if self.is_eof_packet(row_packet) {
            break
        }

        var row = self.parse_row(row_packet, column_count)
        rows.push(row)
    }

    return query_result_t{
        columns = columns,
        rows = rows,
    }
}

// Parse column name
fn conn_t.parse_column_name([u8] packet):string {
    // Simplified column name parsing, skip most fields and find column name directly
    var pos = 0

    // Skip catalog
    var (_1, new_pos) = self.read_length_encoded_string(packet, pos)
    pos = new_pos
    // Skip schema
    var (_2, new_pos2) = self.read_length_encoded_string(packet, pos)
    pos = new_pos2
    // Skip table
    var (_3, new_pos3) = self.read_length_encoded_string(packet, pos)
    pos = new_pos3
    // Skip org_table
    var (_4, new_pos4) = self.read_length_encoded_string(packet, pos)
    pos = new_pos4
    // Read name (column name)
    var (name, _5) = self.read_length_encoded_string(packet, pos)

    return name
}

// Parse row data
fn conn_t.parse_row([u8] packet, int column_count):[string] {
    var row = vec_new<string>("", column_count)
    var pos = 0

    for int i = 0; i < column_count && pos < packet.len(); i += 1 {
        if packet[pos] == 0xfb {
            // NULL value
            row[i] = "NULL"
            pos += 1
        } else {
            // Read length-encoded string
            var (length, new_pos) = self.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                row[i] = packet.slice(pos, pos + length as int) as string
                pos += length as int
            }
        }
    }

    return row
}

// Read MySQL packet
fn conn_t.read_packet():[u8]! {
    var header = vec_new<u8>(0, 4)
    var len = self.conn.read(header)
    if len != 4 {
        throw errorf("Failed to read packet header")
    }

    var length = header[0] as int | (header[1] as int << 8) | (header[2] as int << 16)
    self.seq_id = header[3] + 1

    var payload = vec_new<u8>(0, length)
    len = self.conn.read(payload)
    if len != length {
        throw errorf("Failed to read packet body")
    }

    return payload
}

// Write MySQL packet
fn conn_t.write_packet([u8] payload):void! {
    var length = payload.len()
    [u8] header = [length as u8, (length >> 8) as u8, (length >> 16) as u8, self.seq_id]

    self.seq_id += 1

    self.conn.write(header)
    self.conn.write(payload)
}

// Check if it's an EOF packet
fn conn_t.is_eof_packet([u8] packet):bool {
    return packet.len() > 0 && packet[0] == PACKET_EOF && packet.len() < 9
}

// Read null-terminated string
fn conn_t.read_null_terminated_string([u8] data, int pos):(string, int) {
    var start = pos
    for pos < data.len() && data[pos] != 0 {
        pos += 1
    }
    return (data.slice(start, pos) as string, pos + 1)
}

// Read length-encoded string
fn conn_t.read_length_encoded_string([u8] data, int pos):(string, int) {
    var (length, new_pos) = self.read_length_encoded_int(data, pos)
    pos = new_pos
    if pos + length as int <= data.len() {
        return (data.slice(pos, pos + length as int) as string, pos + length as int)
    }
    return ("", pos)
}

// Read length-encoded integer
fn conn_t.read_length_encoded_int([u8] data, int pos):(u64, int) {
    if pos >= data.len() {
        return (0, pos)
    }

    var first = data[pos]
    match first {
        0xfb -> {
            return (0, pos)
        }
        0xfc -> {
            if pos + 2 >= data.len() {
                return (0, pos)
            }
            var value = mem.read_u16_le(data.slice(pos + 1, pos + 3)) catch e {0}
            return (value as u64, pos + 3)
        }
        0xfd -> {
            if pos + 3 >= data.len() {
                return (0, pos)
            }
            var value = data[pos + 1] as u64 | (data[pos + 2] as u64 << 8) | (data[pos + 3] as u64 << 16)
            return (value, pos + 4)
        }
        0xfe -> {
            if pos + 8 >= data.len() {
                return (0, pos)
            }
            var value = mem.read_u64_le(data.slice(pos + 1, pos + 9)) catch e {0}
            return (value, pos + 9)
        }
        _ -> {
            return (first as u64, pos + 1)
        }
    }
}

// Parse prepare response
fn conn_t.parse_prepare_response([u8] packet, string query):ptr<stmt_t>! {
    if packet.len() < 12 {
        throw errorf("Prepare response packet length insufficient")
    }

    var pos = 1 // Skip status identifier
    var statement_id = mem.read_u32_le(packet.slice(pos, pos + 4)) catch e {0}
    pos += 4
    var column_count = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0}
    pos += 2
    var param_count = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0}

    var stmt = new stmt_t(
        conn = self,
        statement_id = statement_id,
        param_count = param_count,
        column_count = column_count,
        query_string = query,
    )

    // If there are parameters, need to read parameter definition packets
    if param_count > 0 {
        for u16 i = 0; i < param_count; i += 1 {
            self.read_packet()
        }
        // Read parameter EOF packet
        self.read_packet()
    }

    // If there are columns, need to read column definition packets
    if column_count > 0 {
        for u16 i = 0; i < column_count; i += 1 {
            self.read_packet()
        }
        // Read column EOF packet
        self.read_packet()
    }

    return stmt
}

// Execute prepared statement
fn stmt_t.execute(...[string] args):execute_result_t! {
    if self.conn.closed {
        throw errorf("Connection is closed")
    }

    self.conn.seq_id = 0

    var execute_packet = self.build_execute_packet(args)
    self.conn.write_packet(execute_packet)

    var packet = self.conn.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty execute response")
    }

    match packet[0] {
        PACKET_OK -> {
            return self.conn.parse_execute_result(packet)
        }
        PACKET_ERROR -> {
            var error_msg = self.conn.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            throw errorf("Execute method can only be used for non-query statements")
        }
    }
}

// Query with prepared statement
fn stmt_t.query(...[string] args):query_result_t! {
    if self.conn.closed {
        throw errorf("Connection is closed")
    }

    self.conn.seq_id = 0

    var execute_packet = self.build_execute_packet(args)
    self.conn.write_packet(execute_packet)

    var packet = self.conn.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty execute response")
    }

    match packet[0] {
        PACKET_OK -> {
            return query_result_t{columns = [], rows = []}
        }
        PACKET_ERROR -> {
            var error_msg = self.conn.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            return self.parse_binary_query_result(packet)
        }
    }
}

// Close prepared statement
fn stmt_t.close():void! {
    if self.conn.closed {
        return
    }

    self.conn.seq_id = 0

    var close_packet = vec_new<u8>(0, 5)
    close_packet[0] = COM_STMT_CLOSE
    var stmt_id_bytes = mem.write_u32_le(self.statement_id)
    close_packet.slice(1, 5).copy(stmt_id_bytes)

    self.conn.write_packet(close_packet)
}

// Build execute packet
fn stmt_t.build_execute_packet([string] args):[u8]! {
    var packet = vec_cap<u8>(1024)

    // Command type
    packet.push(COM_STMT_EXECUTE)

    // Statement ID
    var stmt_id_bytes = mem.write_u32_le(self.statement_id)
    packet.append(stmt_id_bytes)

    // Flags
    packet.push(0x00)

    // Iteration count
    packet.append([0x01, 0x00, 0x00, 0x00])

    if args.len() > 0 {
        // NULL bitmap
        var null_bitmap_len = (args.len() + 7) / 8
        var null_bitmap = vec_new<u8>(0, null_bitmap_len)
        packet.append(null_bitmap)

        // New parameter binding flag
        packet.push(0x01)

        // Parameter types
        for arg in args {
            packet.append([0xfe, 0x00]) // MYSQL_TYPE_STRING
        }

        // Parameter values
        for arg in args {
            var str_bytes = arg as [u8]
            var length_bytes = self.encode_length_encoded_int(str_bytes.len() as u64)
            packet.append(length_bytes)
            packet.append(str_bytes)
        }
    }

    return packet
}

// Encode length-encoded integer
fn stmt_t.encode_length_encoded_int(u64 value):[u8] {
    if value < 251 {
        return [value as u8]
    } else if value < 65536 {
        var result = vec_new<u8>(0, 3)
        result[0] = 0xfc
        var val_bytes = mem.write_u16_le(value as u16) catch e {[]}
        result.slice(1, 3).copy(val_bytes)
        return result
    } else if value < 16777216 {
        var result = vec_new<u8>(0, 4)
        result[0] = 0xfd
        result[1] = value as u8
        result[2] = (value >> 8) as u8
        result[3] = (value >> 16) as u8
        return result
    } else {
        var result = vec_new<u8>(0, 9)
        result[0] = 0xfe
        var val_bytes = mem.write_u64_le(value) catch e {[]}
        result.slice(1, 9).copy(val_bytes)
        return result
    }
}

// Parse binary query result (for prepared statements)
fn stmt_t.parse_binary_query_result([u8] first_packet):query_result_t! {
    var column_count = first_packet[0] as int

    // Read column definitions
    var columns = vec_new<string>("", column_count)
    var column_types = vec_new<u8>(0, column_count)
    
    for int i = 0; i < column_count; i += 1 {
        var col_packet = self.conn.read_packet()
        columns[i] = self.conn.parse_column_name(col_packet)
        column_types[i] = self.parse_column_type(col_packet)
    }

    // Read EOF packet
    var eof_packet = self.conn.read_packet()

    var rows = vec_new<[string]>([], 0)

    // If not EOF packet, this is the first row of data
    if !self.conn.is_eof_packet(eof_packet) {
        var row = self.parse_binary_row_with_types(eof_packet, column_count, column_types)
        rows.push(row)
    }

    // Read all row data
    for true {
        var row_packet = self.conn.read_packet()

        if self.conn.is_eof_packet(row_packet) {
            break
        }

        var row = self.parse_binary_row_with_types(row_packet, column_count, column_types)
        rows.push(row)
    }

    return query_result_t{
        columns = columns,
        rows = rows,
    }
}

// Parse column type
fn stmt_t.parse_column_type([u8] packet):u8 {
    var pos = 0
    
    // Skip catalog, schema, table, org_table, name, org_name
    var (_1, new_pos) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos
    var (_2, new_pos2) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos2
    var (_3, new_pos3) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos3
    var (_4, new_pos4) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos4
    var (_5, new_pos5) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos5
    var (_6, new_pos6) = self.conn.read_length_encoded_string(packet, pos)
    pos = new_pos6
    
    // Skip fixed length identifier (0x0c)
    if pos < packet.len() && packet[pos] == 0x0c {
        pos += 1
    }
    
    // Skip charset (2 bytes)
    pos += 2
    // Skip column length (4 bytes)
    pos += 4
    
    // Field type (1 byte)
    if pos < packet.len() {
        return packet[pos]
    }
    
    // Default to string type
    return 0xfe
}

// Parse binary row with types
fn stmt_t.parse_binary_row_with_types([u8] packet, int column_count, [u8] column_types):[string] {
    if packet.len() == 0 {
        return vec_new<string>("", column_count)
    }

    // Skip packet header identifier (0x00)
    var pos = 1

    // NULL bitmap length calculation
    var null_bitmap_len = (column_count + 7 + 2) / 8
    if pos + null_bitmap_len > packet.len() {
        return vec_new<string>("", column_count)
    }

    var null_bitmap = packet[pos..pos + null_bitmap_len]
    pos += null_bitmap_len

    var row = vec_new<string>("", column_count)

    for int i = 0; i < column_count; i += 1 {
        // Check NULL bitmap
        var byte_pos = (i + 2) / 8
        var bit_pos = (i + 2) % 8
        if byte_pos < null_bitmap.len() && (null_bitmap[byte_pos] & (1 << bit_pos as u8)) != 0 {
            row[i] = "NULL"
            continue
        }

        // If position exceeds packet length, set to empty string
        if pos >= packet.len() {
            row[i] = ""
            continue
        }

        // Parse data by field type
        var field_value = ""
        var new_pos = pos
        
        if i < column_types.len() {
            var (value, next_pos) = self.parse_binary_field_by_type(packet, pos, column_types[i])
            field_value = value
            new_pos = next_pos
        } else {
            // Default string handling
            var (length, tmp_pos) = self.conn.read_length_encoded_int(packet, pos)
            new_pos = tmp_pos
            if new_pos + length as int <= packet.len() {
                field_value = packet.slice(new_pos, new_pos + length as int) as string
                new_pos += length as int
            }
        }
        
        row[i] = field_value
        pos = new_pos
    }

    return row
}

// Parse binary field by type
fn stmt_t.parse_binary_field_by_type([u8] packet, int pos, u8 field_type):(string, int) {
    match field_type {
        MYSQL_TYPE_DECIMAL|MYSQL_TYPE_NEWDECIMAL -> {
            // For decimal types, treat as string for now
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_TINY -> {
            if pos + 1 <= packet.len() {
                return (fmt.sprintf("%d", packet[pos] as i8), pos + 1)
            }
        }
        MYSQL_TYPE_SHORT -> {
            if pos + 2 <= packet.len() {
                var val = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {0}
                return (fmt.sprintf("%d", val), pos + 2)
            }
        }
        MYSQL_TYPE_LONG|MYSQL_TYPE_INT24 -> {
            if pos + 4 <= packet.len() {
                var val = mem.read_u32_le(packet.slice(pos, pos + 4)) catch e {0}
                return (fmt.sprintf("%d", val), pos + 4)
            }
        }
        MYSQL_TYPE_LONGLONG -> {
            if pos + 8 <= packet.len() {
                var val = mem.read_u64_le(packet.slice(pos, pos + 8)) catch e {0}
                return (fmt.sprintf("%d", val), pos + 8)
            }
        }
        MYSQL_TYPE_FLOAT -> {
            if pos + 4 <= packet.len() {
                var val = mem.read_u32_le(packet.slice(pos, pos + 4)) catch e {0}
                return (fmt.sprintf("%g", val as f32), pos + 4)
            }
        }
        MYSQL_TYPE_DOUBLE -> {
            if pos + 8 <= packet.len() {
                var val = mem.read_u64_le(packet.slice(pos, pos + 8)) catch e {0}
                return (fmt.sprintf("%g", val as f64), pos + 8)
            }
        }
        MYSQL_TYPE_NULL -> {
            return ("NULL", pos)
        }
        MYSQL_TYPE_TIMESTAMP|MYSQL_TYPE_DATE|MYSQL_TYPE_TIME|MYSQL_TYPE_DATETIME|MYSQL_TYPE_YEAR|MYSQL_TYPE_NEWDATE -> {
            // Date/time types, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_VARCHAR|MYSQL_TYPE_VAR_STRING|MYSQL_TYPE_STRING -> {
            // String types
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_TINY_BLOB|MYSQL_TYPE_MEDIUM_BLOB|MYSQL_TYPE_LONG_BLOB|MYSQL_TYPE_BLOB -> {
            // BLOB types, treat as string for now
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_BIT -> {
            // BIT type, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_ENUM|MYSQL_TYPE_SET -> {
            // ENUM and SET types, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        MYSQL_TYPE_GEOMETRY -> {
            // GEOMETRY type, treat as string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
        _ -> {
            // Unknown types, use length-encoded string
            var (length, new_pos) = self.conn.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                return (packet.slice(pos, pos + length as int) as string, pos + length as int)
            }
        }
    }
    
    return ("", pos)
}

// Parse error packet
fn conn_t.parse_error_packet([u8] packet):string {
    if packet.len() < 3 {
        return "Error packet format incorrect"
    }

    var error_code = mem.read_u16_le(packet.slice(1, 3)) catch e {0}
    var error_message = ""

    if packet.len() > 3 {
        if packet[3] == '#'[0] && packet.len() > 9 {
            error_message = packet.slice(9, packet.len()) as string
        } else {
            error_message = packet.slice(3, packet.len()) as string
        }
    }

    return fmt.sprintf("MySQL error %d: %s", error_code, error_message)
}

// Print query results in table format
fn query_result_t.dump():void {
    if self.columns.len() == 0 {
        fmt.printf("Empty result set\n")
        return
    }

    // Calculate maximum width for each column
    var col_widths = vec_new<int>(0, self.columns.len())
    for i, col in self.columns {
        col_widths[i] = col.len()
    }

    for row in self.rows {
        for i, cell in row {
            if i < col_widths.len() && cell.len() > col_widths[i] {
                col_widths[i] = cell.len()
            }
        }
    }

    // Print table header
    fmt.printf("+")
    for width in col_widths {
        for int j = 0; j < width + 2; j += 1 {
            fmt.printf("-")
        }
        fmt.printf("+")
    }
    fmt.printf("\n")

    fmt.printf("|")
    for int i = 0; i < self.columns.len(); i += 1 {
        fmt.printf(" %s ", self.columns[i])
        var padding = col_widths[i] - self.columns[i].len()
        for int j = 0; j < padding; j += 1 {
            fmt.printf(" ")
        }
        fmt.printf("|")
    }
    fmt.printf("\n")

    fmt.printf("+")
    for width in col_widths {
        for int j = 0; j < width + 2; j += 1 {
            fmt.printf("-")
        }
        fmt.printf("+")
    }
    fmt.printf("\n")

    // Print data rows
    for row in self.rows {
        fmt.printf("|")
        for i, cell in row {
            if i < col_widths.len() {
                fmt.printf(" %s ", row[i])
                var padding = col_widths[i] - cell.len()
                for int j = 0; j < padding; j += 1 {
                    fmt.printf(" ")
                }
                fmt.printf("|")
            }
        }
        fmt.printf("\n")
    }

    fmt.printf("+")
    for width in col_widths {
        for int j = 0; j < width + 2; j += 1 {
            fmt.printf("-")
        }
        fmt.printf("+")
    }
    fmt.printf("\n")

    fmt.printf("(%d rows)\n", self.rows.len())
}

fn main():void! {
    fmt.printf("=== MySQL API Refactoring Test ===\n")
    fmt.printf("\n")

    // Create connection
    var c = connect("127.0.0.1:3306", "root", "root")

    fmt.printf("Connection successful!\n")

    // Create and use test database
    fmt.printf("\n=== Create Test Database ===\n")
    var r = c.execute("CREATE DATABASE IF NOT EXISTS test_db")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    fmt.printf("\n=== Use Test Database ===\n")
    r = c.execute("USE test_db")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Create user table
    fmt.printf("\n=== Create User Table ===\n")
    r = c.execute("CREATE TABLE IF NOT EXISTS users (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), email VARCHAR(100))")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Insert data
    fmt.printf("\n=== Insert User Data ===\n")
    r = c.execute("INSERT INTO users (name, email) VALUES ('Zhang San', 'zhangsan@example.com')")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = c.execute("INSERT INTO users (name, email) VALUES ('Li Si', 'lisi@example.com')")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = c.execute("INSERT INTO users (name, email) VALUES ('Wang Wu', 'wangwu@example.com')")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    // Query data
    fmt.printf("\n=== Query User Data ===\n")
    var r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Update data
    fmt.printf("\n=== Update User Data ===\n")
    r = c.execute("UPDATE users SET email = 'zhangsan_new@example.com' WHERE id = 1")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Query data again
    fmt.printf("\n=== Query Updated Data ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Delete data
    fmt.printf("\n=== Delete User Data ===\n")
    r = c.execute("DELETE FROM users WHERE id = 2")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Final query
    fmt.printf("\n=== Final Query Results ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Query system information
    fmt.printf("\n=== Query System Information ===\n")
    r2 = c.query("SELECT NOW() as now_time, VERSION() as version, USER() as `current_user`")
    r2.dump()

    // Test prepared statements
    fmt.printf("\n=== Test Prepared Statements ===\n")

    // Prepare insert statement
    var insert_stmt = c.prepare("INSERT INTO users (name, email) VALUES (?, ?)")

    // Use prepared statement to insert data
    r = insert_stmt.execute("Zhao Liu", "zhaoliu@example.com")
    fmt.printf("Prepared insert affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = insert_stmt.execute("Sun Qi", "sunqi@example.com")
    fmt.printf("Prepared insert affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    // Prepare query statement
    var select_stmt = c.prepare("SELECT * FROM users WHERE id > ?")

    // Use prepared statement to query data
    fmt.printf("\n=== Prepared Query Results (id > 1) ===\n")
    var r3 = select_stmt.query("1")
    r3.dump()

    // Prepare update statement
    var update_stmt = c.prepare("UPDATE users SET email = ? WHERE name = ?")

    // Use prepared statement to update data
    r = update_stmt.execute("zhaoliu_updated@example.com", "Zhao Liu")
    fmt.printf("Prepared update affected rows: %d\n", r.affected_rows)

    // View results after update
    fmt.printf("\n=== Results After Prepared Update ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Close prepared statements
    insert_stmt.close()
    select_stmt.close()
    update_stmt.close()

    // Cleanup
    fmt.printf("\n=== Cleanup Test Data ===\n")
    r = c.execute("DROP TABLE IF EXISTS users")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    c.close()

    fmt.printf("\n=== API Test Completed ===\n")
}
