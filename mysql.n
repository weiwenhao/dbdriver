import io
import net.tcp
import fmt
import mem
import crypto.sha256
import time
import libc
import base64

// MySQL protocol constants
const CLIENT_PROTOCOL_41 = 0x00000200
const CLIENT_SECURE_CONNECTION = 0x00008000
const CLIENT_PLUGIN_AUTH = 0x00080000
const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000

// MySQL commands
const COM_QUERY = 0x03
const COM_QUIT = 0x01

// Packet type identifiers
const PACKET_OK = 0x00
const PACKET_ERROR = 0xff
const PACKET_EOF = 0xfe
const PACKET_AUTH = 0x01

// Authentication plugins
const AUTH_NATIVE_PASSWORD = "mysql_native_password"
const AUTH_CACHING_SHA2 = "caching_sha2_password"

// Authentication status
const AUTH_SUCCESS = 0x03
const AUTH_FAIL = 0x04

// Handshake packet structure
type handshake_packet_t = struct {
    string server_version
    [u8] auth_data
    string auth_plugin
}

// Execute result type
type execute_result_t = struct {
    u64 affected_rows    // Number of affected rows
    u64 last_insert_id   // Last inserted ID
    u16 status_flags     // Status flags
    u16 warnings         // Number of warnings
    string info          // Additional information
}

// Query result type
type query_result_t = struct {
    [string] columns     // Column names
    [[string]] rows      // Data rows
}

// MySQL connection type
type conn_t = struct {
    ptr<tcp.conn_t> conn
    u8 seq_id
    bool closed
}

// Create connection with specified configuration
fn connect(string host, string username, string password):ptr<conn_t>! {
    var conn = tcp.connect_timeout(host, 10000)

    var client = new conn_t(conn, seq_id = 0, closed = false)

    // Execute authentication process
    client.authenticate(username, password)

    return client
}

// Authentication process
fn conn_t.authenticate(string username, string password):void! {
    // Read handshake packet
    var handshake = self.read_handshake()

    // Send authentication response
    self.send_auth_response(username, password, handshake)

    // Handle authentication result
    self.handle_auth_result(password)
}

// Read handshake packet
fn conn_t.read_handshake():handshake_packet_t! {
    var packet = self.read_packet()

    if packet.len() == 0 || packet[0] == PACKET_ERROR {
        throw errorf("Server handshake failed")
    }

    return self.parse_handshake_packet(packet)
}

// Parse handshake packet
fn conn_t.parse_handshake_packet([u8] packet):handshake_packet_t! {
    if packet.len() < 20 {
        throw errorf("Handshake packet length insufficient")
    }

    var pos = 1 // Skip protocol version

    // Parse server version
    var (server_version, new_pos) = self.read_null_terminated_string(packet, pos)
    pos = new_pos

    // Skip connection ID (4 bytes)
    pos += 4

    // Read first part of auth data (8 bytes)
    if pos + 8 > packet.len() {
        throw errorf("Handshake packet format error")
    }
    var auth_data1 = packet.slice(pos, pos + 8)
    pos += 9 // Including reserved byte

    // Skip capability flags and other fields
    pos += 2 // Lower capability flags
    if pos >= packet.len() {
        return handshake_packet_t{
            server_version = server_version,
            auth_data = auth_data1,
            auth_plugin = AUTH_NATIVE_PASSWORD,
        }
    }

    pos += 1  // Character set
    pos += 2  // Status flags
    pos += 2  // Upper capability flags
    var auth_data_len = packet[pos]
    pos += 1
    pos += 10 // Reserved bytes

    // Read second part of auth data
    var auth_data2 = vec_new<u8>(0, 0)
    if auth_data_len > 8 && pos < packet.len() {
        var remaining_len = auth_data_len as int - 8
        if pos + remaining_len <= packet.len() {
            auth_data2 = packet.slice(pos, pos + remaining_len - 1)
            pos += remaining_len
        }
    }

    // Read authentication plugin name
    var (auth_plugin, _) = self.read_null_terminated_string(packet, pos)
    if auth_plugin == "" {
        auth_plugin = AUTH_NATIVE_PASSWORD
    }

    return handshake_packet_t{
        server_version = server_version,
        auth_data = auth_data1.concat(auth_data2),
        auth_plugin = auth_plugin,
    }
}

// Send authentication response
fn conn_t.send_auth_response(string username, string password, handshake_packet_t handshake):void! {
    u32 capabilities = CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | CLIENT_PLUGIN_AUTH | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA

    var auth_response = self.generate_auth_response(password, handshake.auth_data, handshake.auth_plugin)

    var packet = self.build_auth_packet(capabilities, username, auth_response, handshake.auth_plugin)
    self.write_packet(packet)
}

// Generate authentication response
fn conn_t.generate_auth_response(string password, [u8] auth_data, string auth_plugin):[u8] {
    if password == "" {
        return []
    }

    match auth_plugin {
        AUTH_CACHING_SHA2 -> {
            return self.caching_sha2_auth(password, auth_data)
        }
        _ -> {
            return self.native_password_auth(password, auth_data)
        }
    }
}

// Build authentication packet
fn conn_t.build_auth_packet(u32 capabilities, string username, [u8] auth_response, string auth_plugin):[u8]! {
    var packet = vec_cap<u8>(256)

    // Client capability flags (4 bytes)
    var cap_bytes = mem.write_u32_le(capabilities)
    packet.append(cap_bytes)

    // Maximum packet size (4 bytes)
    packet.append([0x00, 0x00, 0x00, 0x01])

    // Character set (1 byte)
    packet.push(0x21) // utf8_general_ci

    // Reserved bytes (23 bytes)
    packet.append(vec_new<u8>(0, 23))

    // Username
    packet.append(username as [u8])
    packet.push(0x00)

    // Authentication response
    packet.push(auth_response.len() as u8)
    packet.append(auth_response)

    // Authentication plugin name
    packet.append(auth_plugin as [u8])
    packet.push(0x00)

    return packet
}

// Handle authentication result
fn conn_t.handle_auth_result(string password):void! {
    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty authentication response")
    }

    match packet[0] {
        PACKET_OK -> {
            return
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        PACKET_AUTH -> {
            self.handle_caching_sha2_auth(packet)
        }
        PACKET_EOF -> {
            throw errorf("Server requested authentication method switch, not supported in this example")
        }
        _ -> {
            throw errorf("Unknown authentication response: 0x%02x", packet[0])
        }
    }
}

// Handle caching_sha2_password authentication
fn conn_t.handle_caching_sha2_auth([u8] packet):void! {
    if packet.len() <= 1 {
        throw errorf("caching_sha2_password authentication packet format error")
    }

    match packet[1] {
        AUTH_SUCCESS -> {
            // Fast authentication successful, read final OK packet
            var final_packet = self.read_packet()
            if final_packet.len() > 0 && final_packet[0] == PACKET_OK {
                return
            }
            throw errorf("Expected to receive final OK packet")
        }
        AUTH_FAIL -> {
            throw errorf("Fast authentication failed")
        }
        _ -> {
            throw errorf("Full authentication required, but RSA encryption not supported in this example")
        }
    }
}

// mysql_native_password authentication
fn conn_t.native_password_auth(string password, [u8] auth_data):[u8] {
    if password == "" {
        return []
    }

    var hash1 = sha256.new().update(password as [u8]).finish()
    var hash2 = sha256.new().update(hash1).finish()

    var combined = auth_data.concat(hash2)
    var hash3 = sha256.new().update(combined).finish()

    var result = vec_new<u8>(0, hash1.len())
    for int i = 0; i < hash1.len(); i += 1 {
        result[i] = hash1[i] ^ hash3[i]
    }

    return result
}

// caching_sha2_password authentication
fn conn_t.caching_sha2_auth(string password, [u8] auth_data):[u8] {
    if password == "" {
        return []
    }

    var hash1 = sha256.new().update(password as [u8]).finish()
    var hash2 = sha256.new().update(hash1).finish()

    var combined = hash2.concat(auth_data)

    var hash3 = sha256.new().update(combined).finish()

    var result = vec_new<u8>(0, hash1.len())
    for int i = 0; i < hash1.len(); i += 1 {
        result[i] = hash1[i] ^ hash3[i]
    }

    return result
}

// Execute non-query statements (INSERT, UPDATE, DELETE, etc.)
fn conn_t.execute(string query):execute_result_t! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet.slice(1, query_packet.len()).copy(query as [u8])

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty query response")
    }

    match packet[0] {
        PACKET_OK -> {
            return self.parse_execute_result(packet)
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            throw errorf("Execute method can only be used for non-query statements")
        }
    }
}

// Execute query statements (SELECT, etc.)
fn conn_t.query(string query):query_result_t! {
    if self.closed {
        throw errorf("Connection is closed")
    }

    self.seq_id = 0

    var query_packet = vec_new<u8>(0, 1 + query.len())
    query_packet[0] = COM_QUERY
    query_packet.slice(1, query_packet.len()).copy(query as [u8])
    println('[query] query_packet is', query_packet as string)

    self.write_packet(query_packet)

    var packet = self.read_packet()

    if packet.len() == 0 {
        throw errorf("Received empty query response")
    }

    match packet[0] {
        PACKET_OK -> {
            // Possibly a query with no results
            return query_result_t{columns = [], rows = []}
        }
        PACKET_ERROR -> {
            var error_msg = self.parse_error_packet(packet)
            throw errorf(error_msg)
        }
        _ -> {
            return self.parse_query_result(packet)
        }
    }
}

// Close connection
fn conn_t.close() {
    if self.closed {
        return
    }

    self.write_packet([COM_QUIT]) catch e {}

    self.conn.close()
    self.closed = true
}

// Parse execute result
fn conn_t.parse_execute_result([u8] packet):execute_result_t {
    var pos = 1 // Skip OK identifier

    var (affected_rows, new_pos) = self.read_length_encoded_int(packet, pos)
    pos = new_pos
    var (last_insert_id, new_pos2) = self.read_length_encoded_int(packet, pos)
    pos = new_pos2

    var status_flags = 0 as u16
    var warnings = 0 as u16

    if pos + 2 <= packet.len() {
        status_flags = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {break 0 as u16}
        pos += 2
    }
    if pos + 2 <= packet.len() {
        warnings = mem.read_u16_le(packet.slice(pos, pos + 2)) catch e {break 0 as u16}
        pos += 2
    }

    var info = ""
    if pos < packet.len() {
        info = packet.slice(pos, packet.len()) as string
    }

    return execute_result_t{
        affected_rows = affected_rows,
        last_insert_id = last_insert_id,
        status_flags = status_flags,
        warnings = warnings,
        info = info,
    }
}

// Parse query result
fn conn_t.parse_query_result([u8] first_packet):query_result_t! {
    var column_count = first_packet[0] as int

    // Read column definitions
    var columns = vec_new<string>("", column_count)
    for int i = 0; i < column_count; i += 1 {
        var col_packet = self.read_packet()
        columns[i] = self.parse_column_name(col_packet)
    }

    // Read EOF packet
    var eof_packet = self.read_packet()

    var rows = vec_new<[string]>([], 0)

    // If not EOF packet, this is the first row of data
    if !self.is_eof_packet(eof_packet) {
        var row = self.parse_row(eof_packet, column_count)
        rows.push(row)
    }

    // Read all row data
    for true {
        var row_packet = self.read_packet()

        if self.is_eof_packet(row_packet) {
            break
        }

        var row = self.parse_row(row_packet, column_count)
        rows.push(row)
    }

    return query_result_t{
        columns = columns,
        rows = rows,
    }
}

// Parse column name
fn conn_t.parse_column_name([u8] packet):string {
    // Simplified column name parsing, skip most fields and find column name directly
    var pos = 0

    // Skip catalog
    var (_1, new_pos) = self.read_length_encoded_string(packet, pos)
    pos = new_pos
    // Skip schema
    var (_2, new_pos2) = self.read_length_encoded_string(packet, pos)
    pos = new_pos2
    // Skip table
    var (_3, new_pos3) = self.read_length_encoded_string(packet, pos)
    pos = new_pos3
    // Skip org_table
    var (_4, new_pos4) = self.read_length_encoded_string(packet, pos)
    pos = new_pos4
    // Read name (column name)
    var (name, _5) = self.read_length_encoded_string(packet, pos)

    return name
}

// Parse row data
fn conn_t.parse_row([u8] packet, int column_count):[string] {
    var row = vec_new<string>("", column_count)
    var pos = 0

    for int i = 0; i < column_count && pos < packet.len(); i += 1 {
        if packet[pos] == 0xfb {
            // NULL value
            row[i] = "NULL"
            pos += 1
        } else {
            // Read length-encoded string
            var (length, new_pos) = self.read_length_encoded_int(packet, pos)
            pos = new_pos
            if pos + length as int <= packet.len() {
                row[i] = packet.slice(pos, pos + length as int) as string
                pos += length as int
            }
        }
    }

    return row
}

// Read MySQL packet
fn conn_t.read_packet():[u8]! {
    var header = vec_new<u8>(0, 4)
    var len = self.conn.read(header)
    if len != 4 {
        throw errorf("Failed to read packet header")
    }

    var length = header[0] as int | (header[1] as int << 8) | (header[2] as int << 16)
    self.seq_id = header[3] + 1

    var payload = vec_new<u8>(0, length)
    len = self.conn.read(payload)
    if len != length {
        throw errorf("Failed to read packet body")
    }

    return payload
}

// Write MySQL packet
fn conn_t.write_packet([u8] payload):void! {
    var length = payload.len()
    [u8] header = [length as u8, (length >> 8) as u8, (length >> 16) as u8, self.seq_id]

    self.seq_id += 1

    self.conn.write(header)
    self.conn.write(payload)
}

// Check if it's an EOF packet
fn conn_t.is_eof_packet([u8] packet):bool {
    return packet.len() > 0 && packet[0] == PACKET_EOF && packet.len() < 9
}

// Read null-terminated string
fn conn_t.read_null_terminated_string([u8] data, int pos):(string, int) {
    var start = pos
    for pos < data.len() && data[pos] != 0 {
        pos += 1
    }
    return (data.slice(start, pos) as string, pos + 1)
}

// Read length-encoded string
fn conn_t.read_length_encoded_string([u8] data, int pos):(string, int) {
    var (length, new_pos) = self.read_length_encoded_int(data, pos)
    pos = new_pos
    if pos + length as int <= data.len() {
        return (data.slice(pos, pos + length as int) as string, pos + length as int)
    }
    return ("", pos)
}

// Read length-encoded integer
fn conn_t.read_length_encoded_int([u8] data, int pos):(u64, int) {
    if pos >= data.len() {
        return (0, pos)
    }

    var first = data[pos]
    match first {
        0xfb -> {
            return (0, pos)
        }
        0xfc -> {
            if pos + 2 >= data.len() {
                return (0, pos)
            }
            var value = mem.read_u16_le(data.slice(pos + 1, pos + 3)) catch e {break 0 as u16}
            return (value as u64, pos + 3)
        }
        0xfd -> {
            if pos + 3 >= data.len() {
                return (0, pos)
            }
            var value = data[pos + 1] as u64 | (data[pos + 2] as u64 << 8) | (data[pos + 3] as u64 << 16)
            return (value, pos + 4)
        }
        0xfe -> {
            if pos + 8 >= data.len() {
                return (0, pos)
            }
            var value = mem.read_u64_le(data.slice(pos + 1, pos + 9)) catch e {break 0 as u64}
            return (value, pos + 9)
        }
        _ -> {
            return (first as u64, pos + 1)
        }
    }
}

// Parse error packet
fn conn_t.parse_error_packet([u8] packet):string {
    if packet.len() < 3 {
        return "Error packet format incorrect"
    }

    var error_code = mem.read_u16_le(packet.slice(1, 3)) catch e {break 0 as u16}
    var error_message = ""

    if packet.len() > 3 {
        if packet[3] == '#'[0] && packet.len() > 9 {
            error_message = packet.slice(9, packet.len()) as string
        } else {
            error_message = packet.slice(3, packet.len()) as string
        }
    }

    return fmt.sprintf("MySQL error %d: %s", error_code, error_message)
}

// Print query results in table format
fn query_result_t.dump():void {
    if self.columns.len() == 0 {
        fmt.printf("Empty result set\n")
        return
    }

    // Calculate maximum width for each column
    var col_widths = vec_new<int>(0, self.columns.len())
    for i, col in self.columns {
        col_widths[i] = col.len()
    }

    for row in self.rows {
        for i, cell in row {
            if i < col_widths.len() && cell.len() > col_widths[i] {
                col_widths[i] = cell.len()
            }
        }
    }

    // Print table header
    fmt.printf("+")
    for width in col_widths {
        for int j = 0; j < width + 2; j += 1 {
            fmt.printf("-")
        }
        fmt.printf("+")
    }
    fmt.printf("\n")

    fmt.printf("|")
    for int i = 0; i < self.columns.len(); i += 1 {
        fmt.printf(" %s ", self.columns[i])
        var padding = col_widths[i] - self.columns[i].len()
        for int j = 0; j < padding; j += 1 {
            fmt.printf(" ")
        }
        fmt.printf("|")
    }
    fmt.printf("\n")

    fmt.printf("+")
    for width in col_widths {
        for int j = 0; j < width + 2; j += 1 {
            fmt.printf("-")
        }
        fmt.printf("+")
    }
    fmt.printf("\n")

    // Print data rows
    for row in self.rows {
        fmt.printf("|")
        for i, cell in row {
            if i < col_widths.len() {
                fmt.printf(" %s ", row[i])
                var padding = col_widths[i] - cell.len()
                for int j = 0; j < padding; j += 1 {
                    fmt.printf(" ")
                }
                fmt.printf("|")
            }
        }
        fmt.printf("\n")
    }

    fmt.printf("+")
    for width in col_widths {
        for int j = 0; j < width + 2; j += 1 {
            fmt.printf("-")
        }
        fmt.printf("+")
    }
    fmt.printf("\n")

    fmt.printf("(%d rows)\n", self.rows.len())
}

fn main():void! {
    fmt.printf("=== MySQL API Refactoring Test ===\n")
    fmt.printf("\n")

    // Create connection
    var c = connect("127.0.0.1:3306", "root", "root")

    fmt.printf("Connection successful!\n")

    // Create and use test database
    fmt.printf("\n=== Create Test Database ===\n")
    var r = c.execute("CREATE DATABASE IF NOT EXISTS test_db")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    fmt.printf("\n=== Use Test Database ===\n")
    r = c.execute("USE test_db")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Create user table
    fmt.printf("\n=== Create User Table ===\n")
    r = c.execute("CREATE TABLE IF NOT EXISTS users (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), email VARCHAR(100))")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Insert data
    fmt.printf("\n=== Insert User Data ===\n")
    r = c.execute("INSERT INTO users (name, email) VALUES ('Zhang San', 'zhangsan@example.com')")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = c.execute("INSERT INTO users (name, email) VALUES ('Li Si', 'lisi@example.com')")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    r = c.execute("INSERT INTO users (name, email) VALUES ('Wang Wu', 'wangwu@example.com')")
    fmt.printf("Affected rows: %d, Last insert ID: %d\n", r.affected_rows, r.last_insert_id)

    // Query data
    fmt.printf("\n=== Query User Data ===\n")
    var r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Update data
    fmt.printf("\n=== Update User Data ===\n")
    r = c.execute("UPDATE users SET email = 'zhangsan_new@example.com' WHERE id = 1")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Query data again
    fmt.printf("\n=== Query Updated Data ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Delete data
    fmt.printf("\n=== Delete User Data ===\n")
    r = c.execute("DELETE FROM users WHERE id = 2")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    // Final query
    fmt.printf("\n=== Final Query Results ===\n")
    r2 = c.query("SELECT * FROM users")
    r2.dump()

    // Query system information
    fmt.printf("\n=== Query System Information ===\n")
    r2 = c.query("SELECT NOW() as now_time, VERSION() as version, USER() as `current_user`")
    r2.dump()

    // Cleanup
    fmt.printf("\n=== Cleanup Test Data ===\n")
    r = c.execute("DROP TABLE IF EXISTS users")
    fmt.printf("Affected rows: %d\n", r.affected_rows)

    c.close()

    fmt.printf("\n=== API Test Completed ===\n")
}
